name: Validate canonical .editorconfig (syntax + analyzer semantics)

# Trigger only when the canonical .editorconfig is modified
on:
  push:
    paths:
      - "BionicCode.CodeStyle/BionicCode.CodeStyle/.editorconfig"
  pull_request:
    paths:
      - "BionicCode.CodeStyle/BionicCode.CodeStyle/.editorconfig"

permissions:
  contents: read

jobs:
  validate-editorconfig:
    name: Validate canonical .editorconfig
    runs-on: ubuntu-latest
    env:
      # If true, the job will fail on unknown analyzer IDs (default: false)
      FAIL_ON_UNKNOWN: "false"
      # Candidate URLs to fetch known analyzer IDs from (best-effort)
      KNOWN_RULES_URLS: >
        https://raw.githubusercontent.com/dotnet/roslyn-analyzers/main/docs/AnalyzerIdList.md
        https://raw.githubusercontent.com/dotnet/roslyn-analyzers/main/Documentation/AnalyzerIds.md
        https://raw.githubusercontent.com/dotnet/roslyn-analyzers/main/docs/AnalyzerList.md

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Validate .editorconfig syntax and analyzer semantics
        shell: bash
        run: |
          set -euo pipefail

          # Path to the canonical editorconfig inside this repo:
          FILE="BionicCode.CodeStyle/BionicCode.CodeStyle/.editorconfig"

          if [ ! -f "$FILE" ]; then
            echo "::warning file=${FILE}::File not found; skipping validation."
            exit 0
          fi

          python - <<'PY'
          import configparser
          import os
          import re
          import sys
          import urllib.request
          import urllib.error

          fname = os.environ.get("EDITORCONFIG_PATH", "BionicCode.CodeStyle/BionicCode.CodeStyle/.editorconfig")
          fname = "BionicCode.CodeStyle/BionicCode.CodeStyle/.editorconfig"

          # Allowed severity keywords (Roslyn editorconfig severities)
          allowed_severities = {"none", "silent", "suggestion", "warning", "error", "default"}

          # Read file for line-based searches and for parser
          with open(fname, "r", encoding="utf-8", errors="replace") as f:
              content = f.read()
              lines = content.splitlines()

          # Parse with configparser (ini-like)
          parser = configparser.ConfigParser(strict=False, interpolation=None)
          try:
              # configparser expects section headers; .editorconfig typically has them.
              parser.read_string(content)
          except Exception as e:
              # emit annotation and exit non-zero
              print(f"::error file={fname},title=.editorconfig parse error::{e}")
              sys.exit(1)

          errors = []
          warnings = []

          # Helper: find first line containing a given pattern (case-insensitive)
          def find_line_for_text(txt):
              pat = re.compile(re.escape(txt), re.IGNORECASE)
              for i, ln in enumerate(lines, start=1):
                  if pat.search(ln):
                      return i
              return None

          # Pattern for analyzer severity keys: dotnet_diagnostic.<RULEID>.severity
          pattern_diag = re.compile(r"dotnet_diagnostic\.([A-Za-z0-9_]+)\.severity$", re.IGNORECASE)
          used_rules = set()
          malformed_keys = []

          for section in parser.sections():
              for raw_key, raw_val in parser.items(section):
                  key = raw_key.strip()
                  val = (raw_val or "").strip()
                  m = pattern_diag.match(key)
                  if m:
                      rule = m.group(1).upper()
                      used_rules.add(rule)
                      sev = val.lower()
                      if sev not in allowed_severities:
                          ln = find_line_for_text(key) or 1
                          errors.append((ln, f"Invalid severity '{val}' for '{key}'. Allowed: {', '.join(sorted(allowed_severities))}"))
                  else:
                      # Heuristic: detect keys that look like they tried to be a severity but are malformed
                      if key.startswith("dotnet_") and "severity" in key.lower():
                          ln = find_line_for_text(key) or 1
                          malformed_keys.append((ln, key))

          for ln, key in malformed_keys:
              errors.append((ln, f"Possibly malformed analyzer key: '{key}'. Expected format: dotnet_diagnostic.<RULEID>.severity"))

          # Best-effort fetch of known analyzer IDs from upstream docs
          known_rules = set()
          urls = os.environ.get("KNOWN_RULES_URLS", "").split()
          for url in urls:
              if not url:
                  continue
              try:
                  with urllib.request.urlopen(url, timeout=10) as resp:
                      if resp.status != 200:
                          continue
                      txt = resp.read().decode("utf-8", errors="ignore")
                      # Find tokens that look like analyzer IDs: e.g. CA1000, CS0168, IDE0090
                      found = set(re.findall(r"\b[A-Z]{1,4}\d{2,5}\b", txt))
                      if found:
                          known_rules.update(found)
              except Exception:
                  continue

          if known_rules:
              for rule in sorted(used_rules):
                  if rule not in known_rules:
                      key_pattern = f"dotnet_diagnostic.{rule}.severity"
                      ln = find_line_for_text(key_pattern) or 1
                      msg = f"Referenced analyzer rule '{rule}' not found in fetched upstream lists; verify the rule ID is correct."
                      warnings.append((ln, msg))
          else:
              print("::notice ::Could not fetch authoritative analyzer ID list; existence checks skipped. This is non-fatal.")

          # Emit annotations
          for ln, msg in warnings:
              if ln:
                  print(f"::warning file={fname},line={ln},title=.editorconfig warning::{msg}")
              else:
                  print(f"::warning file={fname},title=.editorconfig warning::{msg}")

          for ln, msg in errors:
              if ln:
                  print(f"::error file={fname},line={ln},title=.editorconfig error::{msg}")
              else:
                  print(f"::error file={fname},title=.editorconfig error::{msg}")

          fail_on_unknown = os.environ.get("FAIL_ON_UNKNOWN", "false").lower() in ("1", "true", "yes")
          if errors:
              sys.exit(1)
          if fail_on_unknown and warnings:
              sys.exit(1)

          print("Validator completed: no fatal issues found.")
          sys.exit(0)
          PY

      - name: Summary
        if: always()
        run: |
          echo "Validator finished. See workflow annotations for details."
